{
    "collab_server" : "",
    "contents" : "#' frequency table for categorical and logical variables\n#'\n#'the function nonum.table() is to return a frequency table for every categorical and logical variable\n#' @param dafra-a dataframe been taken\n#' @return a frequent table in list\n#' @export\nnonum_table <- function(dafra){\n  tb1 <- lapply(dafra[,sapply(dafra,is.logical)],table) #draw the table for logical variables\n  tb2 <- lapply(dafra[,sapply(dafra,is.factor)],table) #draw the table for factor variables\n  return(list(tb1,tb2))\n}\n\n\n#' Summary for all numeric variables\n#'\n#'the function summary.table() is to return a summary statistics table for each numerical variable\n#' @param dafra-a dataframe been taken\n#' @return a summary statistics table\n#' @export\nsummary_table <- function(dafra){\n  num <- Filter(is.numeric,dafra) #filter all numeric variables\n  return(summary(num)) #return their summary table\n}\n\n\n\n#' R-Square for all numeric variables\n#'\n#'the function rsqure() is going to return a dataframe that contains each pair of column names in the first column (name the column “Variable Pairs”) and the associated r-square value in the second column (name the column “R-Square”)\n#' @param num - a dataframe that all are numeric variables\n#' @return a dataframe that contains each pair of column names and corresponding r-square values\n#' @export\nrsquare <- function(num){\n  colna <- colnames(num) # take out all the variables' names\n  com_num <- combn(colna, 2) #combine the names pairwise\n  VP <- c()\n  R2 <- c()\n  for(i in 1:ncol(com_num)){\n    temp1 <- paste(com_num[1,i],com_num[2,i],sep = '-')\n    VP <- c(VP,temp1)                                   #write the pairwise names and add them in vector\n    a<- num[,com_num[1,i]]\n    b<- num[,com_num[2,i]]\n    model <- lm(a~1+b)\n    temp2 <- summary(model)[\"r.squared\"]                #use linear regression to count and take out corresponding r-square\n    R2 <- c(R2,as.numeric(temp2))\n  }\n  RR <- data.frame(VP,R2)                       #create a dataframe and change its name\n  colnames(RR) <- c(\"Variable Pairs\",\"R-square\")\n  return(RR)\n}\n\n#' correlation coefficient\n#'\n#'the function Cor_pearson() is going to return A data frame that contains each pair of column names in the first column\n#'(name the column “Variable Pairs”) and correlation coefficient (Pearson) for all coefficients whose absolute value\n#'is greater than the correlation threshold (do not repeat any pairs) in the second column\n#' @param num - a dataframe that all are numeric variables\n#' @param threshold - a value being coefficient threshold\n#' @return a dataframe that contains each pair of column names and corresponding r-square values\n#' @export\nCor_pearson <- function(num,threshold = 0){\n  colna <- colnames(num) # take out all the variables' names\n  com_num <- combn(colna, 2) #combine the names pairwise\n  VP2 <- c()\n  Cor <- c()  #create two empty vectors\n  for(i in 1:ncol(com_num)){\n    temp1 <- paste(com_num[1,i],com_num[2,i],sep = '-')  #write pairwise names\n    corr <- cor(num[,com_num[1,i]],num[,com_num[2,i]],method = \"pearson\") # count corresponding Pearson correlation coefficient\n    if(corr >= threshold){\n      VP2 <- c(VP2,temp1)\n      Cor <- c(Cor,corr)  #if correlation coefficient is greater than threshold then add them to vectors\n    }\n  }\n  CRR <- data.frame(VP2,Cor) #create dataframe for pairwise names and correlation coefficients\n  colnames(CRR) <- c(\"Variable Pairs\",\"Pearson Exceeds Threshold\")# rename the dataframe then return the result\n  return(CRR)\n}\n\n\n#' Draw different graps in one picture\n#'\n#'the function is going to draw different graphs in one picture\n#' @param\n#' @return a dataframe that contains each pair of column names and corresponding r-square values\n#' @export\nmultiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n\n  # Make a list from the ... arguments and plotlist\n  plots <- c(list(...), plotlist)\n\n  numPlots = length(plots)\n\n  # If layout is NULL, then use 'cols' to determine layout\n  if (is.null(layout)) {\n    # Make the panel\n    # ncol: Number of columns of plots\n    # nrow: Number of rows needed, calculated from # of cols\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                     ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n\n  if (numPlots==1) {\n    print(plots[[1]])\n\n  } else {\n    # Set up the page\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n\n    # Make each plot, in the correct location\n    for (i in 1:numPlots) {\n      # Get the i,j matrix positions of the regions that contain this subplot\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n\n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}\n\n#' Density-count Histograms\n#'\n#'the function plot_density_count() is thatIf the plot switch parameter is “on”,then plot a pair of\n#'blue histograms with a vertical red line at the mean (one using counts and the other density) for\n#'every numerical variable at each number of bins integer specified in the bin vector parameter.\n#'If the plot switch is set to “grid”, there should be a grid for each count-bin combination and a\n#'separate grid for each density-bin size combination.\n#' @param num - a dataframe that all are numeric variables\n#' @param switch - a character that decide the plot\n#' @param vector - a vector that decide the bins of histograms\n#' @return NUll\n#' @export\nplot_density_count <- function(num,switch=\"on\",vector=NULL){\n  require(ggplot2)\n  require(grid)\n  if(switch == \"on\"){\n    if(!is.null(vector)){ # if vector is NULL then\n      for(j in 1:length(vector)){\n        for(i in 1:ncol(num)){\n\n          mean <- mean(num[,i]) #count the mean of one numeric variable\n\n          p1 <- ggplot(num,aes(x=num[i]),color = \"blue\")+\n            geom_histogram(fill=\"blue\",bins=vector[j])+\n            ggtitle(paste(colnames(num[i]),vector[j],sep=\" bins=\"))+\n            xlab(colnames(num[i]))+\n            geom_vline(xintercept = mean,col=\"red\")  #draw the histogram of count with ggplot and add a red line on graph\n\n          p2 <- ggplot(num,aes(x=num[i],..density..))+\n            geom_histogram(fill=\"blue\",bins=vector[j])+\n            ggtitle(paste(colnames(num[i]),vector[j],sep=\" bins=\"))+\n            xlab(colnames(num[i]))+\n            geom_vline(xintercept = mean,col=\"red\") #draw the histogram of density with ggplot and add a red line on graph\n\n          grid.newpage()\n          pushViewport(viewport(layout = grid.layout(2, 2, heights = unit(c(1, 8), \"null\"))))\n          title <- paste(colnames(num[i]),vector[j],sep=\" bin=\")\n          grid.text(title, vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))\n          print(p1, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))\n          print(p2, vp = viewport(layout.pos.row = 2, layout.pos.col = 2)) #use grid package to separate the picture and plot two histograms\n\n        }\n      }\n    }else{ #\n      for(i in 1:ncol(num)){\n\n        mean <- mean(num[,i]) #count the mean of one numeric variable\n\n        p1 <- ggplot(num,aes(x=num[i]),color = \"blue\")+\n          geom_histogram(fill=\"blue\")+\n          ggtitle(paste(colnames(num[i]),\"default bins\",sep=\" bins=\"))+\n          xlab(colnames(num[i]))+\n          geom_vline(xintercept = mean,col=\"red\")  #draw the histogram of count with ggplot and add a red line on graph\n\n        p2 <- ggplot(num,aes(x=num[i],..density..))+\n          geom_histogram(fill=\"blue\")+\n          ggtitle(paste(colnames(num[i]),\"default bins\",sep=\" bins=\"))+\n          xlab(colnames(num[i]))+\n          geom_vline(xintercept = mean,col=\"red\") #draw the histogram of density with ggplot and add a red line on graph\n\n        grid.newpage()\n        pushViewport(viewport(layout = grid.layout(2, 2, heights = unit(c(1, 8), \"null\"))))\n        title <- paste(colnames(num[i]),\"default bins\",sep=\" bins=\")\n        grid.text(title, vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))\n        print(p1, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))\n        print(p2, vp = viewport(layout.pos.row = 2, layout.pos.col = 2)) #use grid package to separate the picture and plot two histograms\n\n      }\n\n    }\n\n  }else{\n    if(switch == \"grid\"){\n      if(!is.null(vector)){\n        for(j in 1:length(vector)){\n          grid.newpage()\n          his_count <-list()\n          his_density <- list()  #create two empty list for store picture later\n          for(i in 1:ncol(num)){\n            mean <- mean(num[,i])\n            his_count[[i]] <- ggplot(num, aes_string(colnames(num[i])), color = \"blue\") +\n              geom_histogram(fill=\"blue\", bins = vector[j])+\n              labs(title= paste(vector[j], \"bins\"))+ #draw histograms of count and store them in list\n              geom_vline(xintercept = mean,col=\"red\")\n          }\n          multiplot(plotlist = his_count, cols = 2)  #draw all histogram of count with same bins in one picture\n\n          for(i in 1:ncol(num)){\n            mean <- mean(num[,i])\n            his_density[[i]] <- ggplot(num, aes_string(colnames(num[i])), color = \"blue\") +\n              geom_histogram(aes(y= ..density..), fill=\"blue\", bins = vector[j])+\n              labs(title= paste(vector[j], \"bins\"))+ #draw histograms of density and store them in list\n              geom_vline(xintercept = mean,col=\"red\")\n          }\n          multiplot(plotlist = his_density, cols = 2)  #draw all histogram of density with same bins in one picture\n        }\n      }else{\n        grid.newpage()\n        his_count <-list()\n        his_density <- list()  #create two empty list for store picture later\n        for(i in 1:ncol(num)){\n          mean <- mean(num[,i])\n          his_count[[i]] <- ggplot(num, aes_string(colnames(num[i])), color = \"blue\") +\n            geom_histogram(fill=\"blue\")+\n            labs(title= 'default bins')+ #draw histograms of count and store them in list\n            geom_vline(xintercept = mean,col=\"red\")\n        }\n        multiplot(plotlist = his_count, cols = 2)  #draw all histogram of count with same bins in one picture\n\n        for(i in 1:ncol(num)){\n          mean <- mean(num[,i])\n          his_density[[i]] <- ggplot(num, aes_string(colnames(num[i])), color = \"blue\") +\n            geom_histogram(aes(y= ..density..), fill=\"blue\")+\n            labs(title= 'default bins')+ #draw histograms of density and store them in list\n            geom_vline(xintercept = mean,col=\"red\")\n        }\n        multiplot(plotlist = his_density, cols = 2)\n      }\n\n    }\n  }\n}\n\n#' Binary ruler\n#'\n#'the function is going to check if a vector is binary or not\n#' @param v -a vector\n#' @return True or False\n#' @export\nis.binary <- function(v) {\n  x <- unique(v)                    #check all the distinct and put those in a vector x\n  length(x) - sum(is.na(x)) == 2L         #check to see if x only contains 2 distinct values\n}\n\n#' Gray Bar Graph for categorical and binary variables\n#'\n#'this function is to plot a gray bar graph for every categorical and binary variable if the plot switch parameter is “on” or “grid”.\n#' @param data_frame- a dataframe\n#' @param switch- a character\n#' @return NULL\n#' @export\nplot_categ_binary <- function(data_frame,switch){\n  data_frame1 <- data_frame[,sapply(data_frame,is.factor)]\n  data_frame2 <- data_frame[,sapply(data_frame,is.logical)]\n  data_frame3 <- data_frame[,sapply(data_frame,is.binary)]\n  data_frame <-data.frame(data_frame1,data_frame2,data_frame3)\n  if(switch==\"on\"|| switch==\"grid\"){\n    for(i in 1:ncol(data_frame)){\n      p <- ggplot(data_frame,aes(x=data_frame[,i]))+\n        geom_bar(fill='gray')+\n        xlab(colnames(data_frame)[i])\n      print(p)\n    }\n  }\n}\n\n#' Explore1.0\n#'\n#'this function is a foundamental explore1.0\n#'dafra- A data frame\n#' @param  switch - A plot switch that can accept three values :off,on,or grid\n#' @param  threshold-A threshold cut -of fvalue between 0 and 1 for correlations\n#' @param  vector- An optional vector that contains one or more integers\n#' @return a list\n#' @export\nexplore1.0 <- function(dafra,switch = \"on\",threshold = 0,vector = NULL){\n  num <- Filter(is.numeric,dafra) # filter the dataframe and take out all numeric\n  out <- list(nonnum_table = nonum_table(dafra), #create a frequency table for every categorical and logical variable\n              summary_table = summary_table(dafra),#create a summary statistics table for each numerical variable\n              RR = rsquare(num), #create a dataframe that contains pairwise names and their r-square values\n              CRR = Cor_pearson(num,threshold), #create a dataframe that contains pairwise names and their pearson correlation coefficient\n              p1 = plot_density_count(num,switch,vector),\n              p2 = plot_categ_binary(dafra,switch)) #create a list that contain all the results then return\n\n  return(out)\n}\n\n#' Explore2.0\n#'\n#'this function is a foundamental explore2.0\n#'dafra- A data frame\n#' @param  switch  A plot switch that can accept three values :off,on,or grid\n#' @param  threshold A threshold cut -of fvalue between 0 and 1 for correlations\n#' @param  vector An optional vector that contains one or more integers and represent the number of bins\n#' @return a list\n#' @export\nexplore <- function(dafra,switch = 'on', threshold = 0, vector = NULL){\n  # this function is the improvement of explore()\n\n  data_frame <- na.omit(dafra) #cancel the whole line if there is NA exist\n\n  if(!is.data.frame(data_frame)){\n    data_frame <- as.data.frame(data_frame)  #if it is not dataframe, transfer it into dataframe\n  }\n\n\n  while(switch != \"off\" && switch != \"on\" && switch != \"grid\"){   #Check to see if switch is valid input, if not, input until valid switch\n    print(\"invalid input for switch\")\n    switch <- readline(prompt=\"Enter your option(off / on / grid): \")  #re-enter the input\n  }\n\n  while(!is.numeric(threshold) || threshold < 0 || threshold >1 ){    #check to see if threshold is a valid input,if not, input until valid threshold\n    print(\"correlation threshold must be numeric and in range [0,1]\")\n    threshold <- as.numeric(readline(prompt=\"Enter your correlation threshold: \"))   #re-enter the threshold\n  }\n\n  if(!is.null(vector)){\n    if(!is.numeric(vector)||(is.numeric(vector) && (TRUE %in% (vector <= 0)))){ #check if bin vector is all numeric and all not less than 0\n      print(\"the bins vector must be numeric vector and not less than 0, please enter new bins one by one and press 'return' at last to finish input\")\n      vector <- c()\n      bin <- 1\n      while(bin != \"\"){  #input \"return\"  to finish loop\n        bin <- readline(prompt=\"Enter the number of bins: \")->bin1\n        bin1 <- as.numeric(bin1)\n        vector <- c(vector, bin1)\n      }#re-enter the bin vector\n      vector <- na.omit(vector) #cancel the NA\n    }\n\n\n    if (!is.integer(vector)) {  #Check to see if bins are all integer, if not, round it\n      vector <- round(vector)\n    }\n  }\n  out <- explore1.0(data_frame,switch,threshold,vector)\n  class(out) <- \"explore\"\n  return(out)\n}\n\n#'@export\nprint.explore <- function(out,...){\n  cat(\"Frequency table for every categorical and logical variable:\\n\")\n  print(out$nonnum_table)\n  cat(\"\\n\")\n  cat(\"Summary statistics table for each numerical variable:\\n\")\n  print(out$summary_table)\n  cat(\"\\n\")\n  cat(\"R-square of each pair of column:\\n\")\n  print(out$RR)\n  cat(\"\\n\")\n  cat(\"Pearson correlation of each pair of column:\\n\")\n  print(out$CRR)\n  cat(\"\\n\")\n  cat(\"Histogram plots of each numeric variables:\\n\")\n  print(\"please see the plot part\")\n  cat(\"\\n\")\n  cat(\"Bar plots of each categorical variables:\\n\")\n  print(\"please see the plot part\")\n}\n\n",
    "created" : 1478200215525.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2144026841",
    "id" : "1921A905",
    "lastKnownWriteTime" : 1478208133,
    "last_content_update" : 1478208133096,
    "path" : "~/GitHub/Zhang_Yichen_explore/explore2.0/R/explore_all_function.R",
    "project_path" : "R/explore_all_function.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}